{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, log, WalletInitializationError, WalletLoginError, isHexStrict, getChainConfig } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { SignTypedDataVersion, TYPED_MESSAGE_SCHEMA, typedSignatureHash, personalSign, signTypedData, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { stripHexPrefix, isValidAddress, privateToAddress, addHexPrefix } from 'ethereumjs-util';\nimport { get } from '@toruslabs/http-helpers';\nimport assert from 'assert';\nimport jsonschema from 'jsonschema';\nimport BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';\nimport Common, { Hardfork } from '@ethereumjs/common';\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processSignTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\n\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\n\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV4: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        }),\n        skipLookupNetwork: !!config.skipLookupNetwork\n      },\n      state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId,\n      addChain = true,\n      lookup = true\n    } = _ref2;\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    const {\n      rpcTarget,\n      displayName\n    } = currentChainConfig;\n\n    if (addChain) {\n      try {\n        await this.connector.sendCustomRequest({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId,\n            chainName: displayName,\n            rpcUrls: [rpcTarget]\n          }]\n        });\n      } catch (error) {\n        log.error(error);\n      }\n    }\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId\n        }]\n      });\n    } catch (error) {\n      log.error(error); // ignore this error because metamask & others return provider.result as null\n      // wallet connect thinks this is wrong\n\n      if (error.message !== \"JSON RPC response format is invalid\") {\n        throw error;\n      }\n    }\n\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    if (lookup) await this.lookupNetwork(this.connector);\n  }\n\n  async addChain(chainConfig) {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const {\n      rpcTarget,\n      displayName\n    } = chainConfig;\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: chainConfig.chainId,\n          chainName: displayName,\n          rpcUrls: [rpcTarget]\n        }]\n      });\n      super.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n      throw error;\n    }\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    if (!this.config.skipLookupNetwork) await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload.params[0]; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {}; // Handle rpcUrl update\n\n        this.configure({\n          chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl,\n            chainNamespace: CHAIN_NAMESPACES.EIP155\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig,\n      skipLookupNetwork: params.skipLookupNetwork\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1e18\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1e9\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\"); // Setter Maps\n\nconst toBigNumber = {\n  hex: n => typeof n === \"string\" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16),\n  dec: n => new BigNumber(n, 10)\n};\nconst toNormalizedDenomination = {\n  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)\n};\nconst toSpecifiedDenomination = {\n  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)\n};\nconst baseChange = {\n  hex: n => n.toString(16),\n  dec: n => new BigNumber(n).toString(10)\n};\n\nconst converter = params => {\n  const {\n    value,\n    fromNumericBase,\n    fromDenomination,\n    toNumericBase,\n    toDenomination,\n    numberOfDecimals\n  } = params;\n  let convertedValue = toBigNumber[fromNumericBase](value);\n\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);\n  }\n\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);\n  }\n\n  if (numberOfDecimals) {\n    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n\n  return convertedValue;\n};\n\nconst conversionUtil = (value, _ref) => {\n  let {\n    fromNumericBase = \"hex\",\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals\n  } = _ref;\n  return converter({\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    value: value || \"0\"\n  });\n};\n\nfunction decGWEIToHexWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\"\n  });\n}\n\nfunction hexWEIToDecGWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\"\n  });\n}\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction normalizeGWEIDecimalNumbers(n) {\n  const numberAsWEIHex = decGWEIToHexWEI(n);\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\n\nasync function fetchEip1159GasEstimates(url) {\n  const estimates = await get(url);\n\n  const normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),\n    low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)\n    }),\n    medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)\n    }),\n    high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)\n    })\n  });\n\n  return normalizedEstimates;\n}\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\n\n\nasync function fetchLegacyGasPriceEstimates(url) {\n  const result = await get(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\",\n    mode: \"cors\"\n  });\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice\n  };\n}\n\nconst validateTypedMessageParams = (parameters, activeChainId) => {\n  var _data$domain;\n\n  try {\n    assert.ok(parameters && typeof parameters === \"object\", \"Params must be an object.\");\n    assert.ok(\"data\" in parameters, 'Params must include a \"data\" field.');\n    assert.ok(\"from\" in parameters, 'Params must include a \"from\" field.');\n    assert.ok(typeof parameters.from === \"string\" && isValidAddress(parameters.from), '\"from\" field must be a valid, lowercase, hexadecimal Ethereum address string.');\n    let data = null;\n    let chainId = null;\n\n    switch (parameters.version) {\n      case SignTypedDataVersion.V1:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(Array.isArray(data), \"params.data must be an array.\");\n        assert.doesNotThrow(() => {\n          typedSignatureHash(data);\n        }, \"Signing data must be valid EIP-712 typed data.\");\n        break;\n\n      case SignTypedDataVersion.V3:\n      case SignTypedDataVersion.V4:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(data.primaryType in data.types, \"Primary type of \\\"\".concat(data.primaryType, \"\\\" has no type definition.\"));\n        const validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA.properties);\n        assert.strictEqual(validation.errors.length, 0, \"Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.\");\n        chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;\n\n        if (chainId) {\n          assert.ok(!Number.isNaN(activeChainId), \"Cannot sign messages for chainId \\\"\".concat(chainId, \"\\\", because Web3Auth is switching networks.\"));\n\n          if (typeof chainId === \"string\") {\n            chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n          }\n\n          assert.strictEqual(chainId, activeChainId, \"Provided chainId \\\"\".concat(chainId, \"\\\" must match the active chainId \\\"\").concat(activeChainId, \"\\\"\"));\n        }\n\n        break;\n\n      default:\n        assert.fail(\"Unknown typed data version \\\"\".concat(parameters.version, \"\\\"\"));\n    }\n  } catch (error) {\n    throw ethErrors.rpc.invalidInput({\n      message: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nasync function signTx(txParams, privKey, txFormatter) {\n  const finalTxParams = await txFormatter.formatTransaction(txParams);\n  const common = await txFormatter.getCommonConfiguration();\n  const unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {\n    common\n  });\n  const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n  return signedTx;\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    txFormatter,\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n      const params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {\n        version: SignTypedDataVersion.V1\n      });\n\n      validateTypedMessageParams(params, finalChainId);\n      const data = typeof params.data === \"string\" ? JSON.parse(params.data) : params.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n\n  return new BigNumber$1(a, 10).lt(b, 10);\n}\n\nfunction bnToHex(inputBn) {\n  return addHexPrefix(inputBn.toString(16));\n}\n\nfunction hexToBn(inputHex) {\n  if (BigNumber$1.isBigNumber(inputHex)) return inputHex;\n  return new BigNumber$1(stripHexPrefix(inputHex), 16);\n}\n\nfunction BnMultiplyByFraction(targetBN, numerator, denominator) {\n  const numberBN = new BigNumber$1(numerator);\n  const denomBN = new BigNumber$1(denominator);\n  return targetBN.multipliedBy(numberBN).dividedBy(denomBN);\n}\n\nconst LegacyGasAPIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices\";\nconst EIP1559APIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees\";\nconst TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\"\n};\nconst TRANSACTION_TYPES = {\n  SENT_ETHER: \"sentEther\",\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  STANDARD_TRANSACTION: \"transaction\"\n};\nconst GAS_ESTIMATE_TYPES = {\n  FEE_MARKET: \"fee-market\",\n  LEGACY: \"legacy\",\n  ETH_GASPRICE: \"eth_gasPrice\",\n  NONE: \"none\"\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass TransactionFormatter {\n  constructor(_ref) {\n    let {\n      getProviderEngineProxy\n    } = _ref;\n\n    _defineProperty(this, \"chainConfig\", null);\n\n    _defineProperty(this, \"getProviderEngineProxy\", void 0);\n\n    _defineProperty(this, \"isEIP1559Compatible\", false);\n\n    this.getProviderEngineProxy = getProviderEngineProxy;\n  }\n\n  get providerProxy() {\n    return this.getProviderEngineProxy();\n  }\n\n  async init() {\n    this.chainConfig = await this.providerProxy.request({\n      method: \"eth_provider_config\",\n      params: []\n    });\n    this.isEIP1559Compatible = await this.getEIP1559Compatibility();\n  }\n\n  async getCommonConfiguration() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const {\n      displayName: name,\n      chainId\n    } = this.chainConfig;\n    const hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;\n    const customChainParams = {\n      name,\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork\n    };\n    return Common.custom(customChainParams);\n  }\n\n  async formatTransaction(txParams) {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n\n    const clonedTxParams = _objectSpread$1({}, txParams);\n\n    if (clonedTxParams.nonce === undefined) clonedTxParams.nonce = await this.providerProxy.request({\n      method: \"eth_getTransactionCount\",\n      params: [txParams.from, \"latest\"]\n    });\n\n    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {\n      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;\n      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas; // if gas is not provided explicitly, estimate it.\n\n      if (!clonedTxParams.gas) {\n        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n        if (defaultGasLimit) {\n          clonedTxParams.gasLimit = defaultGasLimit;\n        }\n      } else {\n        clonedTxParams.gasLimit = clonedTxParams.gas;\n      }\n\n      return clonedTxParams;\n    }\n\n    if (!clonedTxParams.gas) {\n      const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n      if (defaultGasLimit) {\n        clonedTxParams.gasLimit = defaultGasLimit;\n      }\n    } else {\n      clonedTxParams.gasLimit = clonedTxParams.gas;\n    }\n\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas\n    } = await this.getDefaultGasFees(clonedTxParams);\n\n    if (this.isEIP1559Compatible) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;\n        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === \"string\" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n\n        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          clonedTxParams.maxFeePerGas = defaultGasPrice;\n        }\n\n        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available  then we set maxPriorityFeePerGas to\n          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;\n        }\n      } // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n\n      delete clonedTxParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n      delete clonedTxParams.maxPriorityFeePerGas;\n      delete clonedTxParams.maxFeePerGas;\n    } // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n\n\n    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {\n      clonedTxParams.gasPrice = defaultGasPrice;\n    }\n\n    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    clonedTxParams.chainId = this.chainConfig.chainId;\n    return clonedTxParams;\n  }\n\n  async fetchEthGasPriceEstimate() {\n    const gasPrice = await this.providerProxy.request({\n      method: \"eth_gasPrice\",\n      params: []\n    });\n    return {\n      gasPrice: hexWEIToDecGWEI(gasPrice).toString()\n    };\n  }\n\n  async getEIP1559Compatibility() {\n    const latestBlock = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    });\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n    return !!supportsEIP1559;\n  }\n\n  async fetchGasFeeEstimateData() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const isLegacyGasAPICompatible = this.chainConfig.chainId === \"0x1\";\n    const chainId = Number.parseInt(this.chainConfig.chainId, 16);\n    let gasData;\n\n    try {\n      if (this.isEIP1559Compatible) {\n        // TODO: kovan is not working due to a bug in metamask api\n        const estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch (e) {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate();\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE\n        };\n      } catch (error) {\n        throw new Error(\"Gas fee/price estimation failed. Message: \".concat(error.message));\n      }\n    }\n\n    return gasData;\n  }\n\n  async getDefaultGasFees(txParams) {\n    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {\n      return {};\n    }\n\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType\n      } = await this.fetchGasFeeEstimateData();\n\n      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        const {\n          medium: {\n            suggestedMaxPriorityFeePerGas,\n            suggestedMaxFeePerGas\n          } = {}\n        } = gasFeeEstimates;\n\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: decGWEIToHexWEI(gasFeeEstimates.medium)\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n\n    const {\n      gasPrice\n    } = await this.fetchEthGasPriceEstimate();\n    return {\n      gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))\n    };\n  }\n\n  async estimateTxGas(txMeta) {\n    const txParams = _objectSpread$1({}, txMeta); // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n\n\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    const gas = await this.providerProxy.request({\n      method: \"eth_estimateGas\",\n      params: [txParams]\n    });\n    return gas;\n  }\n\n  async analyzeGasUsage(txMeta) {\n    const block = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    }); // fallback to block gasLimit\n\n    const blockGasLimitBN = hexToBn(block.gasLimit);\n    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);\n    let estimatedGasHex = bnToHex(saferGasLimitBN);\n\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error) {\n      log.warn(error);\n    }\n\n    return {\n      blockGasLimit: block.gasLimit,\n      estimatedGasHex\n    };\n  }\n\n  addGasBuffer(initialGasLimitHex, blockGasLimitHex) {\n    let multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;\n    const initialGasLimitBn = hexToBn(initialGasLimitHex);\n    const blockGasLimitBn = hexToBn(blockGasLimitHex);\n    const upperGasLimitBn = blockGasLimitBn.multipliedBy(0.9).dp(0, 1);\n    const bufferedGasLimitBn = initialGasLimitBn.multipliedBy(multiplier).dp(0, 1); // if initialGasLimit is above blockGasLimit, dont modify it\n\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn); // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn); // otherwise use blockGasLimit\n\n    return bnToHex(upperGasLimitBn);\n  }\n\n  async determineTransactionCategory(txParameters) {\n    const {\n      data,\n      to\n    } = txParameters;\n    let code = \"\";\n    let txCategory;\n\n    if (data && !to) {\n      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    } else {\n      try {\n        code = await this.providerProxy.request({\n          method: \"eth_getCode\",\n          params: [to, \"latest\"]\n        });\n      } catch (error) {\n        log.warn(error);\n      }\n\n      const codeIsEmpty = !code || code === \"0x\" || code === \"0x0\";\n      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    }\n\n    return {\n      transactionCategory: txCategory,\n      code\n    };\n  }\n\n  async getDefaultGasLimit(txParams) {\n    const {\n      transactionCategory\n    } = await this.determineTransactionCategory(_objectSpread$1({}, txParams));\n\n    if (txParams.gas) {\n      return txParams.gas;\n    }\n\n    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txParams.data) {\n        throw Error(\"TxGasUtil - Trying to call a function on a non-contract address\");\n      }\n\n      const TWENTY_ONE_THOUSAND = 21000; // This is a standard ether simple send, gas requirement is exactly 21k\n\n      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));\n    }\n\n    const {\n      blockGasLimit,\n      estimatedGasHex\n    } = await this.analyzeGasUsage(txParams); // add additional gas buffer to our estimation for safety\n\n    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);\n    return gasLimit;\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const txFormatter = new TransactionFormatter({\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const providerHandlers = getProviderHandlers({\n      txFormatter,\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await txFormatter.init();\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n\n    if (this.state.chainId !== chainId) {\n      this._providerEngineProxy.emit(\"chainChanged\", chainId);\n\n      this._providerEngineProxy.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };","map":{"version":3,"sources":["../src/rpc/walletMidddleware.ts","../src/rpc/ethRpcMiddlewares.ts","../src/rpc/jrpcClient.ts","../src/providers/injectedProviders/walletConnectUtils.ts","../src/providers/injectedProviders/WalletConnectProvider.ts","../src/providers/converter.ts","../src/providers/privateKeyProviders/TransactionFormatter/utils.ts","../src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","../src/providers/utils.ts","../src/providers/privateKeyProviders/TransactionFormatter/constants.ts","../src/providers/privateKeyProviders/TransactionFormatter/index.ts","../src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts"],"names":["str","processTypedMessageV4","address","accounts","getAccounts","normalizedAccounts","_address","normalizedAddress","message","res","ethErrors","txParams","req","from","validateAndNormalizeKeyholder","processTransaction","processSignTransaction","extraParams","msgParams","data","processEthSignMessage","version","processTypedMessage","processTypedMessageV3","firstParam","secondParam","resemblesAddress","warning","processPersonalMessage","processEncryptionPublicKey","ciphertext","processDecryptMessage","getPrivateKey","createScaffoldMiddleware","eth_accounts","createAsyncMiddleware","eth_private_key","eth_coinbase","eth_sendTransaction","eth_signTransaction","eth_sign","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","personal_sign","eth_getEncryptionPublicKey","eth_decrypt","ethMiddleware","mergeMiddleware","eth_syncing","createWalletMiddleware","createChainSwitchMiddleware","switchChain","chainParams","length","addChain","wallet_addEthereumChain","wallet_switchEthereumChain","updatePrivatekey","accountParams","wallet_updateAccount","end","next","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","createChainIdMiddleware","createProviderConfigMiddleware","connector","result","_","WalletConnectProvider","constructor","config","chainConfig","chainNamespace","CHAIN_NAMESPACES","EIP155","skipLookupNetwork","state","chainId","providerFactory","params","enable","code","method","setupProvider","lookup","currentChainConfig","displayName","chainName","rpcUrls","log","error","WalletInitializationError","lookupNetwork","WalletLoginError","connectedHexChainId","isHexStrict","setupEngine","providerHandlers","getProviderHandlers","createEthMiddleware","engine","createJsonRpcClient","provider","providerFromEngine","onConnectorStateUpdate","rpcUrl","payload","connectedChainId","maybeConfig","getChainConfig","BIG_NUMBER_WEI_MULTIPLIER","BIG_NUMBER_GWEI_MULTIPLIER","BIG_NUMBER_ETH_MULTIPLIER","toBigNumber","hex","n","stripHexPrefix","dec","toNormalizedDenomination","WEI","bigNumber","GWEI","ETH","toSpecifiedDenomination","BigNumber","baseChange","converter","numberOfDecimals","convertedValue","conversionUtil","fromNumericBase","value","toNumericBase","fromDenomination","toDenomination","numberAsWEIHex","decGWEIToHexWEI","numberAsGWEI","hexWEIToDecGWEI","estimates","get","normalizedEstimates","estimatedBaseFee","normalizeGWEIDecimalNumbers","low","suggestedMaxPriorityFeePerGas","suggestedMaxFeePerGas","medium","high","referrer","referrerPolicy","mode","FastGasPrice","validateTypedMessageParams","assert","parameters","isValidAddress","SignTypedDataVersion","JSON","Array","typedSignatureHash","validation","jsonschema","TYPED_MESSAGE_SCHEMA","Number","finalTxParams","txFormatter","common","unsignedEthTx","signedTx","Buffer","getProviderEngineProxy","privateToAddress","providerEngineProxy","signTx","txHash","rawMessageSig","signMessage","privKeyBuffer","sig","personalSign","privateKey","finalChainId","V1","signTypedData","V3","V4","getEncryptionPublicKey","stripped","buff","decrypted","decrypt","encryptedData","privKey","a","b","addHexPrefix","inputBn","BnMultiplyByFraction","targetBN","numerator","denominator","numberBN","denomBN","LegacyGasAPIEndpoint","EIP1559APIEndpoint","TRANSACTION_ENVELOPE_TYPES","LEGACY","ACCESS_LIST","FEE_MARKET","TRANSACTION_TYPES","SENT_ETHER","CONTRACT_INTERACTION","DEPLOY_CONTRACT","STANDARD_TRANSACTION","GAS_ESTIMATE_TYPES","ETH_GASPRICE","NONE","TransactionFormatter","providerProxy","init","getCommonConfiguration","hardfork","Hardfork","customChainParams","networkId","defaultHardfork","Common","formatTransaction","clonedTxParams","defaultGasLimit","gasPrice","maxFeePerGas","maxPriorityFeePerGas","defaultMaxPriorityFeePerGas","bnLessThan","defaultMaxFeePerGas","defaultGasPrice","fetchEthGasPriceEstimate","getEIP1559Compatibility","latestBlock","supportsEIP1559","fetchGasFeeEstimateData","isLegacyGasAPICompatible","fetchEip1159GasEstimates","gasData","gasFeeEstimates","gasEstimateType","fetchLegacyGasPriceEstimates","getDefaultGasFees","estimateTxGas","gas","analyzeGasUsage","block","blockGasLimitBN","hexToBn","saferGasLimitBN","estimatedGasHex","bnToHex","blockGasLimit","addGasBuffer","multiplier","initialGasLimitBn","blockGasLimitBn","upperGasLimitBn","bufferedGasLimitBn","determineTransactionCategory","to","txCategory","codeIsEmpty","transactionCategory","getDefaultGasLimit","Error","TWENTY_ONE_THOUSAND","gasLimit","EthereumPrivateKeyProvider","chainSwitchMiddleware","updateAccount","existingKey","network","parseInt","getChainSwitchMiddleware","chainSwitchHandlers","nativeCurrency","ticker","tickerName","blockExplorer","getAccountMiddleware","accountHandlers","createAccountMiddleware"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, log, WalletInitializationError, WalletLoginError, isHexStrict, getChainConfig } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { SignTypedDataVersion, TYPED_MESSAGE_SCHEMA, typedSignatureHash, personalSign, signTypedData, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { stripHexPrefix, isValidAddress, privateToAddress, addHexPrefix } from 'ethereumjs-util';\nimport { get } from '@toruslabs/http-helpers';\nimport assert from 'assert';\nimport jsonschema from 'jsonschema';\nimport BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';\nimport Common, { Hardfork } from '@ethereumjs/common';\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processSignTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV4: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        }),\n        skipLookupNetwork: !!config.skipLookupNetwork\n      },\n      state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId,\n      addChain = true,\n      lookup = true\n    } = _ref2;\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    const {\n      rpcTarget,\n      displayName\n    } = currentChainConfig;\n\n    if (addChain) {\n      try {\n        await this.connector.sendCustomRequest({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId,\n            chainName: displayName,\n            rpcUrls: [rpcTarget]\n          }]\n        });\n      } catch (error) {\n        log.error(error);\n      }\n    }\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId\n        }]\n      });\n    } catch (error) {\n      log.error(error); // ignore this error because metamask & others return provider.result as null\n      // wallet connect thinks this is wrong\n\n      if (error.message !== \"JSON RPC response format is invalid\") {\n        throw error;\n      }\n    }\n\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    if (lookup) await this.lookupNetwork(this.connector);\n  }\n\n  async addChain(chainConfig) {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const {\n      rpcTarget,\n      displayName\n    } = chainConfig;\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: chainConfig.chainId,\n          chainName: displayName,\n          rpcUrls: [rpcTarget]\n        }]\n      });\n      super.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n      throw error;\n    }\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    if (!this.config.skipLookupNetwork) await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload.params[0]; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {}; // Handle rpcUrl update\n\n        this.configure({\n          chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl,\n            chainNamespace: CHAIN_NAMESPACES.EIP155\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig,\n      skipLookupNetwork: params.skipLookupNetwork\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1e18\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1e9\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\"); // Setter Maps\n\nconst toBigNumber = {\n  hex: n => typeof n === \"string\" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16),\n  dec: n => new BigNumber(n, 10)\n};\nconst toNormalizedDenomination = {\n  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)\n};\nconst toSpecifiedDenomination = {\n  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)\n};\nconst baseChange = {\n  hex: n => n.toString(16),\n  dec: n => new BigNumber(n).toString(10)\n};\n\nconst converter = params => {\n  const {\n    value,\n    fromNumericBase,\n    fromDenomination,\n    toNumericBase,\n    toDenomination,\n    numberOfDecimals\n  } = params;\n  let convertedValue = toBigNumber[fromNumericBase](value);\n\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);\n  }\n\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);\n  }\n\n  if (numberOfDecimals) {\n    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n\n  return convertedValue;\n};\n\nconst conversionUtil = (value, _ref) => {\n  let {\n    fromNumericBase = \"hex\",\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals\n  } = _ref;\n  return converter({\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    value: value || \"0\"\n  });\n};\n\nfunction decGWEIToHexWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\"\n  });\n}\n\nfunction hexWEIToDecGWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\"\n  });\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction normalizeGWEIDecimalNumbers(n) {\n  const numberAsWEIHex = decGWEIToHexWEI(n);\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\nasync function fetchEip1159GasEstimates(url) {\n  const estimates = await get(url);\n\n  const normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),\n    low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)\n    }),\n    medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)\n    }),\n    high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)\n    })\n  });\n\n  return normalizedEstimates;\n}\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\n\nasync function fetchLegacyGasPriceEstimates(url) {\n  const result = await get(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\",\n    mode: \"cors\"\n  });\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice\n  };\n}\nconst validateTypedMessageParams = (parameters, activeChainId) => {\n  var _data$domain;\n\n  try {\n    assert.ok(parameters && typeof parameters === \"object\", \"Params must be an object.\");\n    assert.ok(\"data\" in parameters, 'Params must include a \"data\" field.');\n    assert.ok(\"from\" in parameters, 'Params must include a \"from\" field.');\n    assert.ok(typeof parameters.from === \"string\" && isValidAddress(parameters.from), '\"from\" field must be a valid, lowercase, hexadecimal Ethereum address string.');\n    let data = null;\n    let chainId = null;\n\n    switch (parameters.version) {\n      case SignTypedDataVersion.V1:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(Array.isArray(data), \"params.data must be an array.\");\n        assert.doesNotThrow(() => {\n          typedSignatureHash(data);\n        }, \"Signing data must be valid EIP-712 typed data.\");\n        break;\n\n      case SignTypedDataVersion.V3:\n      case SignTypedDataVersion.V4:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(data.primaryType in data.types, \"Primary type of \\\"\".concat(data.primaryType, \"\\\" has no type definition.\"));\n        const validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA.properties);\n        assert.strictEqual(validation.errors.length, 0, \"Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.\");\n        chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;\n\n        if (chainId) {\n          assert.ok(!Number.isNaN(activeChainId), \"Cannot sign messages for chainId \\\"\".concat(chainId, \"\\\", because Web3Auth is switching networks.\"));\n\n          if (typeof chainId === \"string\") {\n            chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n          }\n\n          assert.strictEqual(chainId, activeChainId, \"Provided chainId \\\"\".concat(chainId, \"\\\" must match the active chainId \\\"\").concat(activeChainId, \"\\\"\"));\n        }\n\n        break;\n\n      default:\n        assert.fail(\"Unknown typed data version \\\"\".concat(parameters.version, \"\\\"\"));\n    }\n  } catch (error) {\n    throw ethErrors.rpc.invalidInput({\n      message: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nasync function signTx(txParams, privKey, txFormatter) {\n  const finalTxParams = await txFormatter.formatTransaction(txParams);\n  const common = await txFormatter.getCommonConfiguration();\n  const unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {\n    common\n  });\n  const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n  return signedTx;\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    txFormatter,\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n      const params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {\n        version: SignTypedDataVersion.V1\n      });\n\n      validateTypedMessageParams(params, finalChainId);\n      const data = typeof params.data === \"string\" ? JSON.parse(params.data) : params.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n\n  return new BigNumber$1(a, 10).lt(b, 10);\n}\nfunction bnToHex(inputBn) {\n  return addHexPrefix(inputBn.toString(16));\n}\nfunction hexToBn(inputHex) {\n  if (BigNumber$1.isBigNumber(inputHex)) return inputHex;\n  return new BigNumber$1(stripHexPrefix(inputHex), 16);\n}\nfunction BnMultiplyByFraction(targetBN, numerator, denominator) {\n  const numberBN = new BigNumber$1(numerator);\n  const denomBN = new BigNumber$1(denominator);\n  return targetBN.multipliedBy(numberBN).dividedBy(denomBN);\n}\n\nconst LegacyGasAPIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices\";\nconst EIP1559APIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees\";\nconst TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\"\n};\nconst TRANSACTION_TYPES = {\n  SENT_ETHER: \"sentEther\",\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  STANDARD_TRANSACTION: \"transaction\"\n};\nconst GAS_ESTIMATE_TYPES = {\n  FEE_MARKET: \"fee-market\",\n  LEGACY: \"legacy\",\n  ETH_GASPRICE: \"eth_gasPrice\",\n  NONE: \"none\"\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TransactionFormatter {\n  constructor(_ref) {\n    let {\n      getProviderEngineProxy\n    } = _ref;\n\n    _defineProperty(this, \"chainConfig\", null);\n\n    _defineProperty(this, \"getProviderEngineProxy\", void 0);\n\n    _defineProperty(this, \"isEIP1559Compatible\", false);\n\n    this.getProviderEngineProxy = getProviderEngineProxy;\n  }\n\n  get providerProxy() {\n    return this.getProviderEngineProxy();\n  }\n\n  async init() {\n    this.chainConfig = await this.providerProxy.request({\n      method: \"eth_provider_config\",\n      params: []\n    });\n    this.isEIP1559Compatible = await this.getEIP1559Compatibility();\n  }\n\n  async getCommonConfiguration() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const {\n      displayName: name,\n      chainId\n    } = this.chainConfig;\n    const hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;\n    const customChainParams = {\n      name,\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork\n    };\n    return Common.custom(customChainParams);\n  }\n\n  async formatTransaction(txParams) {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n\n    const clonedTxParams = _objectSpread$1({}, txParams);\n\n    if (clonedTxParams.nonce === undefined) clonedTxParams.nonce = await this.providerProxy.request({\n      method: \"eth_getTransactionCount\",\n      params: [txParams.from, \"latest\"]\n    });\n\n    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {\n      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;\n      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas; // if gas is not provided explicitly, estimate it.\n\n      if (!clonedTxParams.gas) {\n        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n        if (defaultGasLimit) {\n          clonedTxParams.gasLimit = defaultGasLimit;\n        }\n      } else {\n        clonedTxParams.gasLimit = clonedTxParams.gas;\n      }\n\n      return clonedTxParams;\n    }\n\n    if (!clonedTxParams.gas) {\n      const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n      if (defaultGasLimit) {\n        clonedTxParams.gasLimit = defaultGasLimit;\n      }\n    } else {\n      clonedTxParams.gasLimit = clonedTxParams.gas;\n    }\n\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas\n    } = await this.getDefaultGasFees(clonedTxParams);\n\n    if (this.isEIP1559Compatible) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;\n        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === \"string\" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n\n        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          clonedTxParams.maxFeePerGas = defaultGasPrice;\n        }\n\n        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available  then we set maxPriorityFeePerGas to\n          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;\n        }\n      } // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n\n      delete clonedTxParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n      delete clonedTxParams.maxPriorityFeePerGas;\n      delete clonedTxParams.maxFeePerGas;\n    } // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n\n\n    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {\n      clonedTxParams.gasPrice = defaultGasPrice;\n    }\n\n    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    clonedTxParams.chainId = this.chainConfig.chainId;\n    return clonedTxParams;\n  }\n\n  async fetchEthGasPriceEstimate() {\n    const gasPrice = await this.providerProxy.request({\n      method: \"eth_gasPrice\",\n      params: []\n    });\n    return {\n      gasPrice: hexWEIToDecGWEI(gasPrice).toString()\n    };\n  }\n\n  async getEIP1559Compatibility() {\n    const latestBlock = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    });\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n    return !!supportsEIP1559;\n  }\n\n  async fetchGasFeeEstimateData() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const isLegacyGasAPICompatible = this.chainConfig.chainId === \"0x1\";\n    const chainId = Number.parseInt(this.chainConfig.chainId, 16);\n    let gasData;\n\n    try {\n      if (this.isEIP1559Compatible) {\n        // TODO: kovan is not working due to a bug in metamask api\n        const estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch (e) {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate();\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE\n        };\n      } catch (error) {\n        throw new Error(\"Gas fee/price estimation failed. Message: \".concat(error.message));\n      }\n    }\n\n    return gasData;\n  }\n\n  async getDefaultGasFees(txParams) {\n    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {\n      return {};\n    }\n\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType\n      } = await this.fetchGasFeeEstimateData();\n\n      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        const {\n          medium: {\n            suggestedMaxPriorityFeePerGas,\n            suggestedMaxFeePerGas\n          } = {}\n        } = gasFeeEstimates;\n\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: decGWEIToHexWEI(gasFeeEstimates.medium)\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n\n    const {\n      gasPrice\n    } = await this.fetchEthGasPriceEstimate();\n    return {\n      gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))\n    };\n  }\n\n  async estimateTxGas(txMeta) {\n    const txParams = _objectSpread$1({}, txMeta); // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n\n\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    const gas = await this.providerProxy.request({\n      method: \"eth_estimateGas\",\n      params: [txParams]\n    });\n    return gas;\n  }\n\n  async analyzeGasUsage(txMeta) {\n    const block = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    }); // fallback to block gasLimit\n\n    const blockGasLimitBN = hexToBn(block.gasLimit);\n    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);\n    let estimatedGasHex = bnToHex(saferGasLimitBN);\n\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error) {\n      log.warn(error);\n    }\n\n    return {\n      blockGasLimit: block.gasLimit,\n      estimatedGasHex\n    };\n  }\n\n  addGasBuffer(initialGasLimitHex, blockGasLimitHex) {\n    let multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;\n    const initialGasLimitBn = hexToBn(initialGasLimitHex);\n    const blockGasLimitBn = hexToBn(blockGasLimitHex);\n    const upperGasLimitBn = blockGasLimitBn.multipliedBy(0.9).dp(0, 1);\n    const bufferedGasLimitBn = initialGasLimitBn.multipliedBy(multiplier).dp(0, 1); // if initialGasLimit is above blockGasLimit, dont modify it\n\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn); // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn); // otherwise use blockGasLimit\n\n    return bnToHex(upperGasLimitBn);\n  }\n\n  async determineTransactionCategory(txParameters) {\n    const {\n      data,\n      to\n    } = txParameters;\n    let code = \"\";\n    let txCategory;\n\n    if (data && !to) {\n      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    } else {\n      try {\n        code = await this.providerProxy.request({\n          method: \"eth_getCode\",\n          params: [to, \"latest\"]\n        });\n      } catch (error) {\n        log.warn(error);\n      }\n\n      const codeIsEmpty = !code || code === \"0x\" || code === \"0x0\";\n      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    }\n\n    return {\n      transactionCategory: txCategory,\n      code\n    };\n  }\n\n  async getDefaultGasLimit(txParams) {\n    const {\n      transactionCategory\n    } = await this.determineTransactionCategory(_objectSpread$1({}, txParams));\n\n    if (txParams.gas) {\n      return txParams.gas;\n    }\n\n    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txParams.data) {\n        throw Error(\"TxGasUtil - Trying to call a function on a non-contract address\");\n      }\n\n      const TWENTY_ONE_THOUSAND = 21000; // This is a standard ether simple send, gas requirement is exactly 21k\n\n      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));\n    }\n\n    const {\n      blockGasLimit,\n      estimatedGasHex\n    } = await this.analyzeGasUsage(txParams); // add additional gas buffer to our estimation for safety\n\n    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);\n    return gasLimit;\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const txFormatter = new TransactionFormatter({\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const providerHandlers = getProviderHandlers({\n      txFormatter,\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await txFormatter.init();\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n\n    if (this.state.chainId !== chainId) {\n      this._providerEngineProxy.emit(\"chainChanged\", chainId);\n\n      this._providerEngineProxy.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };\n//# sourceMappingURL=ethereumProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}